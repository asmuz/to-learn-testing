# Глава 1. Процесс Тестирования

## Тестирование

**Что такое тестирование?**

Хотя и написано много определений, по своей сути тестирование — это процесс сравнения того "что есть" с тем, "как должно быть". Наиболее формальное определение дается в стандарте IEEE 610.12-1990, “Глоссарий стандартов IEEE по терминологии разработок программного обеспечения”, который определяет “тестирование” как:
>“Процесс наблюдения за выполнением программы в специальных условиях и вынесения на этой основе оценки каких-либо ее аспектов”.

*Специальные условия*, упоминаемые в этом определении, воплощены в тестовые сценарии, которые и являются темой этой книги.

**По своей сути тестирование — это процесс сравнения того "что есть" с тем, "как
должно быть".**

Рик Крэйг и Стефан Яскил предлагают более расширенное определение тестирования программ в их книге “Систематическое тестирование программного обеспечения”.

> “Тестирование - это параллельный жизненный цикл процесса разработки, использования и поддержки средств тестирования для того, чтобы измерять и улучшать качество тестируемой программы”.

Тестирование включает планирование, анализ и дизайн, что приводит к созданию тестовых сценариев в дополнение к фокусировке IEEE на выполнении тестов.

У разных организаций и разных людей разнообразные представления о целях тестирования программного обеспечения. Борис Бейзер описывает следующие пять уровней законченности тестирования (он называет их фазами, но мы знаем, что более корректен термин “уровень”, которых обычно пять):

**Уровень 0.**
  - Нет разницы между тестированием и отладкой. Тестирование не имеет никакой другой цели, кроме помощи при отладке
  - Дефекты могут быть обнаружены, но усилия для их нахождения не оформлены.

**Уровень 1.**
  - Целью тестирования является демонстрация того, что программа работает
  - Такой подход, который начинается с предпосылки, что программа работает верно (в основном), может ослепить нас при поиске дефектов. Глинфорд Майерс писал, что при таком проведении тестирования могут подсознательно выбираться тестовые сценарии, которые не должны провалиться. Не будут созданы “дьявольские” тесты, необходимые для поиска глубоко скрытых дефектов.

**Уровень 2.**
  - Целью тестирования является демонстрация того, что программа не работает
  - Это совсем другое мышление. Предполагается, что программа не работает, и задача тестировщика - найти ее дефекты. При таком подходе будут сознательно выбираться такие тестовые сценарии, которые смогут оценить уголки и трещины системы, её границы и краевые значения, используя дьявольски построенные тестовые сценарии.

**Уровень 3.**
  - Целью тестирования является не доказательство чего-либо, а уменьшение риска того, что программа не будет работать, до приемлемой величины
  - В то время как можно признать систему некорректной при помощи всего лишь одного тестового сценария, невозможно доказать, что она верна. Потребуются тесты со всевозможными валидными и невалидными сочетаниями во входных данных. Целью является понимание качества программы при наличии в ней дефектов с предоставлением программистам информации о недостатках программы и обеспечение управления оценкой негативного воздействия на организацию в случае, если система будет поставлена клиентам в текущем состоянии.

**Уровень 4.**
  - Тестирование - это не игра. Это умственная дисциплина, результатом которой является программа с низким уровнем риска без больших усилий в тестировании
  - На этом заключительном уровне мы с самого начала концентрируемся на создании более проверяемых программ. Сюда входят просмотр и контроль требований, проектирование и разработка. Вдобавок это означает написание кода, включающего в себя такие средства, которые тестировщик легко сможет использовать для получения данных во время работы программы. Более того, это означает написание самодиагностируемого кода, который сообщит об ошибках быстрее, чем тестировщики их обнаружат.

### Распространенные проблемы

Когда я спрашиваю своих студентов о проблемах, с которыми они сталкиваются в тестировании, то они, как правило, отвечают:
  - не достаточно времени для проверки должным образом;
  - слишком много входных комбинаций для тестирования;
  - не хватает времени для полного тестирования;
  - сложности в определении ожидаемых результатов для каждого теста;
  - отсутствующие или быстро изменяющиеся требования;
  - недостаточно времени для тщательного тестирования;
  - отсутствие обучения в процессе тестирования;
  - отсутствует инструмент для поддержки;
  - менеджмент либо не понимает тестирование, либо (по-видимому) не заботится о качестве;
  - не хватает времени.

В этой книге нет "волшебной эльфийской пыльцы", которую можно использовать для создания дополнительного времени, лучших требований или более просвещенного менеджмента. Однако, она содержит методики, которые сделают вас более квалифицированными и эффективными в тестировании, помогая выбрать и построить тестовые сценарии, которые обнаружат существенно больше дефектов, чем
было у вас раньше, используя меньше ресурсов.

### Тестовые сценарии

Для того, чтобы быть наиболее квалифицированными и эффективными, тестовые сценарии должны быть спроектированы, а не придуманы на скорую руку. Слово "дизайн" имеет много определений:
  - Задумать или моделировать в уме; изобретать: ​ *изобрести хорошую причину для посещения звездной конференции по тестированию*. Сформулировать план; разрабатывать: *разработать маркетинговую стратегию для нового продукта*.
  - Методично планировать, обычно в задокументированной форме: планировать строение;
планировать тестовый сценарий;
  - Создавать или придумывать для конкретной цели или эффекта: игра создана для привлечения всех возрастов.
  - Для достижения цели или результата; намереваться.
  - Создавать или исполнять художественный или высококвалифицированный метод.

Для того, чтобы быть наиболее профессиональными и эффективными, тестовые
сценарии должны быть спроектированы, а не придуманы на скорую руку. Каждое из этих определений относится к разработке хорошего тестового сценария. Что касается проектирования тестов, Роджер Прессман писал:

> Проектирование тестов для программного обеспечения и других технических продуктов может быть таким же манящим, как и первоначальное проектирование самого продукта. Тем не менее... программисты часто заботятся о тестировании с запозданием, разрабатывая тестовые сценарии которые "вроде правильные", имея при этом мало уверенности в том, что они являются полными. Помня о целях тестирования, мы должны разработать такие тесты, которые будут иметь наивысшую вероятность нахождения большинства ошибок при минимальном количестве времени и усилий*.

Хорошо спроектированный тест-кейс состоит из трех частей:
  - входные данные,
  - результаты;
  - порядок выполнения.

Тест-кейс состоит из входных данных, результатов и порядка выполнения.

### Входные данные

В качестве входных данных обычно рассматриваются данные, введенные с клавиатуры. Несмотря на то, что они являются важным источником входных данных для системы, данные также могут поступать и из других источников - данные от взаимодействующих устройств; данные, считанные из файлов или баз данных; состояние, в котором система находится в момент поступления данных и окружение, в котором эта система выполняется.

### Результаты

Результаты так же разнообразны. Часто результаты представляются всего лишь данными, отображаемыми на компьютерном экране. Кроме того, данные могут быть отправлены во взаимодействующие системы и на внешние устройства. Данные могут быть записаны в файлы или базы данных. При выполнении системы состояние или окружение могут быть изменены.

Все уместные входные значения и результаты являются важными компонентами тестового сценария. Определение ожидаемых результатов при проектировании тестов является функцией "оракула". Оракулом является любая программа, процесс или данные, которые тестировщик предоставляет вместе с ожидаемым результатом теста. Бейзер перечисляет следующие пять типов оракулов:

  - Детские оракулы - просто запустите программу и посмотрите, что появится. Если это выглядит правильно, это должно быть верным.
  - Наборы регрессионных тестов - запустите программу и сравните результат с результатами таких же тестов, запущенных на предыдущей версии этой программы.
  - Признанные данные - запустите программу и сравните результаты с образцом, таким как таблица, формула или другое допустимое описание действительного результата.
  - Приобретенные наборы тестов - запустите программу со стандартизированным набором тестов, который был создан ранее и проверен. Такие программы, как компиляторы, веб-браузеры, и SQL-процессоры (язык структурированных запросов) часто проверяются такими наборами.
  - Существующая программа - запустите программу и сравните результат с другой версией этой же программы.

### Порядок выполнения

Существуют два стиля оформления тестового сценария, касающиеся порядка проведения теста.
  - Последовательные тестовые сценарии - тестовые случаи могут основываться друг на друге. Например, первый тестовый сценарий использует конкретное свойство программы, а затем покидает систему в таком состоянии, чтобы мог быть выполнен второй тестовый сценарий. При тестировании баз данных рассматриваются такие тестовые сценарии:
    - Создать запись
    - Прочитать запись
    - Обновить запись
    - Прочитать запись
    - Удалить запись
    - Прочитать удаленную запись
  - Каждый из этих тестов можно построить на предыдущих тестах. Преимуществом является то, что каждый тест, как правило, меньше и проще. Недостатком является то, что если провалится один тест, то последующие тесты могут стать недействительными.
  - Независимые тестовые сценарии - каждый тестовый сценарий является полностью автономным.Тесты не зависят друг от друга и не требуют, чтобы другие тесты были выполнены успешно. Преимуществом является то, что любое количество тестов может быть выполнено в любом порядке. Недостатком является то, что каждый тест, как правило, больше и сложнее, и, следовательно, сложнее для проектирования, создания и поддержки.

### Виды тестирования

Зачастую тестирование разделяется на тестирование черного ящика и тестирование белого ящика.

**Тестирование черного ящика​** представляет собой стратегию, в которой тестирование основано исключительно на требованиях и спецификациях. В отличие от своего дополнения, тестирования белого ящика, тестирование черного ящика не требует знания внутренних путей, структуры или реализации проверяемой программы.

**Тестирование белого ящика​** представляет собой стратегию, в которой тестирование основано на внутренних путях, структуре и реализации проверяемой программы. В отличие от дополняющего тестирования черного ящика, тестирование белого ящика обычно требует детальных знаний в области программирования.

Дополнительным видом тестирования является​ **тестирование серого ящика**. П
ри таком подходе мы заглядываем в проверяемый «ящик» настолько, чтобы понять, как он был реализован. Потом мы закрываем коробку и используем наши знания для того, чтобы выбрать наиболее эффективные тесты черного ящика.

### Уровни тестирования

Обычно тестирование, и, следовательно, проектирование тестового сценария, осуществляется на четырех различных уровнях:
  - **Модульное тестирование​** - единицей тестирования является "наименьший" кусочек программы, которую создает разработчик. Как правило, это работа одного программиста, которая хранится в одном файле на диске. Разные языки программирования содержат разные модули: в C++ и Java модулем является класс; в C модулем является функция; в менее структурированных языках, таких как Basic и COBOL, модулем может быть вся программа.

  - **Интеграционное тестирование**​ - мы собираем модули вместе в подсистему и, в заключение, в систему. Вполне возможно, что модули прекрасно функционируют изолированно, но сломаются, когда будут объединены. Классическим примером является следующая программа на C и ее дочерняя функция:
```C
/* основная программа */
void oops(int);
int main(){
oops(42); /* вызывается функция oops и передается целое число*/
return 0;
}
```
```C
/* функция oops (в отдельном файле) */
#include <stdio.h>
void oops(double x) {/* ожидает тип double, а не int! */
printf ("%f\n",x); /* Будет печатать мусор (скорее всего, 0) */
}
```
Если эти модули были протестированы индивидуально, то каждый из них, казалось бы, функционировал верно. В этом случае дефект возникает только тогда, когда два модуля объединены. Основная программа передает функции oops ​ целое число, но oops ​ ожидает действительное число и в результате получается беда. Жизненно важно выполнять интеграционное тестирование, пока процесс интеграции продолжается.

  - **Системное тестирование​** . Система состоит из всего программного обеспечения (и, возможно, включает устройства, руководство пользователя, обучающие материалы и т.д.), которое составляет продукт, поставленный клиенту. Системное тестирование фокусируется на дефектах, которые появляются на этом, высшем уровне интеграции. Обычно системное тестирование включает множество видов тестирования: функциональное, юзабилити-тестирование, тестирование безопасности, тестирование интернациолизации и локализации, тестирование надежности и доступности, тестирование производительности и эффективности, тестирование резервных копий и их восстановления, тестирование переносимости и многое другое. Эта книга разбирает только функциональное тестирование. Несмотря на то, что другие типы тестирования важны, они находятся за пределами этой книги.

  - **Приемочное тестирование​** - определяется как тестирование, которое при удачном завершении приведет к принятию клиентом программы и передаче нам его денег. С точки зрения клиента, они обычно желают наиболее исчерпывающее приемочное тестирование (эквивалент уровня системного тестирования). С точки зрения поставщика, мы обычно желаем минимально возможный уровень тестирования, который приведет к передаче денег. Типичные стратегические вопросы, которые должны быть заданы перед приемочным тестированием: Кто определяет уровень приемочного тестирования? Кто создает тестовые сценарии? Кто выполняет тесты? Каков критерий прохождения/провала приемочного теста? Когда и как мы получим оплату?

Классическими уровнями тестирования являются модульное, интеграционное, системное и приемочное тестирование.

Не все системы поддаются использованию этих уровней. Эти уровни предполагают, что существует большой период времени между разработкой модулей и интеграцией их в подсистемы и в системы. В web-разработке обычно возможно развитие от концепта до разработки и готового продукта за несколько часов. В этом случае модульное, интеграционное и системное тестирование не имеют большого смысла. Многие веб-тестировщики используют альтернативный набор уровней:
  - качество кода;
  - функциональность;
  - удобство использования;
  - производительность;
  - безопасность.

### Невозможность тестирования всего

В своей монументальной книге "Тестирование объектно-ориентированных систем" Роберт Биндер предоставляет превосходный пример невозможности тестирования "всего".

Рассмотрим следующую программу:
```C
int blech (int j) {
j = j - 1; // должно быть j = j + 1
j = j / 30000;
return j;
}
```

Обратите внимание, что вторая строка не правильная! Функция ​ blech принимает целое j, вычитает из него единицу, делит получившееся значение на 30 000 (целочисленное деление целых чисел без остатка) и возвращает вычисленное значение. Если на компьютере, выполняющем эту программу, целые числа реализованы с использованием 16 бит, то наименьшим из возможных входных значений является число -32768, а наибольшим 32767.
Таким образом, существует 65536 возможных входов в эту крошечную программу (а в программу вашей организации, вероятно, больше). Будет ли у вас время (и выносливость) для создания 65 536 тестовых сценариев? Конечно, нет. Поэтому, какие входные значения мы выбираем?

Рассмотрим следующие входные значения и их способность обнаружить этот дефект.

| Входное значение (j) | Ожидаемый результат  | Фактический результат |
| --- | --- | --- |
| 1 | 0 | 0 |
| 42 | 0 | 0 |
| 40000 | 1 | 1 |
| -64000 | -2 | -2 |

Ой! Обратите внимание, что ни один из выбранных тестов не обнаружил этот дефект. На самом деле только четыре из возможных 65536 входных значений смогут обнаружить этот дефект. Каков шанс того, что вы выберите все четыре? Каков шанс того, что вы выберите одно из четырех? Какова вероятность того, что вы выиграете в лотерею? Является ли ваш ответ одинаковым для каждого из этих трех вопросов?

### Резюме

  - Тестирование - это параллельный жизненный цикл процесса разработки, использования и поддержки средств тестирования для того, чтобы измерять и улучшать качество тестируемой программы (Крэйг и Яскил).
  - Проектирование тестов для программного обеспечения и других технических продуктов может быть таким же манящим, как и первоначальное проектирование самого продукта. Тем не менее... программисты часто заботятся о тестировании с запозданием, разрабатывая тестовые сценарии которые "вроде правильные", имея при этом мало уверенности в том, что они являются полными. Помня о целях тестирования, мы должны разработать такие тесты, которые будут иметь наивысшую вероятность нахождения большинства ошибок при минимальном количестве времени и усилий (Прессман).
  - Тестирование черного ящика - это стратегия, при которой тестирование основано исключительно на требованиях и спецификациях. Тестирование белого ящика - это стратегия, при которой тестирование основано на внутренних путях, структуре и реализации тестируемого программного обеспечения.
  - Обычно тестирование и, следовательно, проектирование тестовых сценариев, представлено на четырех различных уровнях: модульном, интеграционном, системном и приемочном.

### Практика

Какие четыре входных значения для функции blech​ найдут скрытый дефект? Как вы определили их? Что это предлагает вам как подход для поиска других дефектов?
