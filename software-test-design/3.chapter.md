# Глава 3. Тестирование классов эквивалентности

> "На четвертый день разведки Амазонки, Байрон вылез из своей автокамеры, проверил последние новости на своем карманном компьютере (далее PDA), оснащенном технологией беспроводной связи, и понял, что терзание, которое он чувствовал в желудке, было ни страхом - нет, он не боялся, скорее был в приподнятом настроении - ни напряжением - нет, он, вообще-то, был скорее расслаблен - так что это был, вероятно, паразит." *Чак Килан*

### Введение

Тестирование классов эквивалентности​ - это техника, используемая для уменьшения числа тестовых наборов до выполнимого уровня при сохранении приемлемого уровня покрытия тестами. Эта простая техника используется интуитивно почти всеми тестировщиками, даже если они не знают о ней формально как о методе тест-дизайна. Многие тестировщики выявили её полезность логически, в то время как другие открыли её просто из-за нехватки времени на более тщательное тестирование.

Рассмотрим ситуацию. Мы пишем модуль для системы отдела кадров, который определяет, в каком порядке нужно рассматривать заявления о приёме на работу в зависимости от возраста кандидата.

Правила нашей организации таковы:
  - от 0 до 16​ - не принимаются
  - от 16 до 18​ - могут быть приняты только на неполный рабочий день
  - от 18 до 55​ - могут быть приняты как штатные сотрудники на полный рабочий день
  - от 55 до 99​ - не принимаются​ *

**Примечание**

Если вы видите проблему в таком описании требований, не волнуйтесь. Они так написаны с определенной целью, и будут исправлены в следующей главе.

**Наблюдение**

Следуя этим правилам, наша организация не приняла бы на работу ни доктора Дуги Хаузера, ни полковника Харланда Сандерса, потом что один из них слишком молод, а другой - слишком стар.

Нужно ли нам проверять этот модуль для следующих значений возраста: 0, 1, 2, 3, 4, 5, 6, 7, 8, ..., 90, 91, 92, 93, 94, 95, 96, 97, 98, 99? Если у нас есть огромное количество времени (и это не учитывая отупляющего повторения при почасовой оплате), то, конечно, нужно. Если программист реализовал модуль со следующим программным кодом, то нам придется проверить каждое значение возраста (если у вас нет опыта в программировании, не переживайте. Эти примеры просты. Просто читайте код и вам станет все понятно):
```C
If (applicantAge == 0) hireStatus = "NO";
If (applicantAge == 1) hireStatus = "NO";
If (applicantAge == 14) hireStatus = "NO";
If (applicantAge == 15) hireStatus = "NO";
If (applicantAge == 16) hireStatus = "PART";
If (applicantAge == 17) hireStatus = "PART";
If (applicantAge == 18) hireStatus = "FULL";
If (applicantAge == 19) hireStatus = "FULL";
If (applicantAge == 53) hireStatus = "FULL";
If (applicantAge == 54) hireStatus = "FULL";
If (applicantAge == 55) hireStatus = "NO";
If (applicantAge == 56) hireStatus = "NO";
If (applicantAge == 98) hireStatus = "NO";
If (applicantAge == 99) hireStatus = "NO";
```

Учитывая эту реализацию, факт того, что любой набор тестов прошел успешно, ничего не говорит нам о следующем тесте, который мы можем выполнить. Он может пройти успешно, а может завершиться ошибкой.

К счастью, программисты не пишут код подобным образом (по крайней мере, не очень часто). Хороший программист напишет этот код так:
```C
If (applicantAge >= 0 && applicantAge <=16)
hireStatus="NO";
If (applicantAge >= 16 && applicantAge <=18)
hireStatus="PART";
If (applicantAge >= 18 && applicantAge <=55)
hireStatus="FULL";
If (applicantAge >= 55 && applicantAge <=90)
hireStatus="NO";
```
Из данной типовой реализации видно, что для первого требования нам не нужно проверять 0, 1, 2, ... 14, 15 и 16. Необходимо проверить только одно значение. И какое оно? Любое значение в данном диапазоне подойдет не хуже других. То же самое верно для всех остальных диапазонов. Диапазоны значений, подобные описанным, называются ​ классами эквивалентности. Класс эквивалентности представляет собой набор данных, которые либо одинаково обрабатываются модулем, либо их обработка выдает одинаковые результаты. При тестировании любое значение данных, входящее в класс эквивалентности, аналогично любому иному значению класса. В частности, мы можем ожидать, что:
  - если один тестовый сценарий в классе эквивалентности обнаруживает дефект, то все другие тестовые сценарии в том же классе эквивалентности обнаружат этот дефект.
  - если один тестовый сценарий в классе эквивалентности не обнаруживает дефект, то все другие тестовые сценарии в том же классе эквивалентности не обнаружат этот дефект.

### Ключевой момент

Набор тестов формирует класс эквивалентности, если вы полагаете, что:
  - они все проверяют одно и то же.
  - если один тест ловит ошибку, то и остальные, вероятно, тоже его поймают.
  - если один тест не ловит ошибку, то и остальные, вероятно, тоже его не поймают.

Сэм Канер."Тестирование программного обеспечения".
Этот подход предполагает, что существует спецификация, которая определяет различные эквивалентные классы для тестирования. Также предполагается, что программист не сделал таких странных вещей, как:
```C
if (applicantAge >= 0 && applicantAge <= 16 )
hireStatus="NO";
if (applicantAge >= 16 && applicantAge <= 18 )
hireStatus="PART";
if (applicantAge >= 18 && applicantAge <= 41 )
hireStatus="FULL";
//странное условие ниже
if (applicantAge == 42 && applicantName == " Lee")
hireStatus="Немедленно принять на работу с огромной зарплатой";
if (applicantAge == 42 && applicantName <> " Lee")
hireStatus="FULL";
//конец странного условия
if (applicantAge >= 43 && applicantAge <= 55 )
hireStatus="FULL";
if (applicantAge >= 55 && applicantAge <= 99 )
hireStatus="NO";
```

Используя классы эквивалентности, мы уменьшаем число тестовых сценариев со 100 (тестирование каждого возраста) до 4 (тестирование одного возраста в каждом классе эквивалентности) - значительная экономия.
Теперь мы готовы начать тестирование? Вероятно, нет. Что насчет таких входных данных как 969, -42, FRED или &$#! ? Должны ли мы создавать тестовые сценарии для некорректных входных данных? Ответ, который вы получите от любого хорошего консультанта: "Возможно". Для того, чтобы понять этот ответ, мы должны проверить подход, который пришел из объектно-ориентированного мира, названный "​проектирование-по-контракту".

**Заметка**

По Библии, возраст Мафусаила, когда он умер, был 969 лет (Быт 5:27). Спасибо Гидеону, который сделал эту информацию легко доступной в комнате моего отеля без необходимости высокоскоростного интернет соединения. С точки зрения закона, ​ контракт - это юридически обязательное соглашение между двумя (или более) лицами, которое описывает, что каждое из лиц обещает делать или не делать. Каждое из этих обещаний полезно другому.

В подходе "проектирование-по-контракту" модули (в парадигме объектно-ориентированного программирования они называются "методами", но "модуль" является более общим термином) определены в терминах предусловий и постусловий. Постусловия определяют, что модуль обещает сделать (вычислить значение, открыть файл, напечатать отчет, обновить запись в базе данных, изменить состояние системы и т.д.). Предусловия описывают требования к модулю, при которых он переходит в состояние, описываемое постусловиями. Например, если у нас есть модуль "openFile", что он обещает сделать? Открыть файл.

Какие будут разумные предусловия для этого модуля? Во-первых, файл должен существовать, во-вторых, мы должны предоставить имя (или другую идентифицирующую информацию), в-третьих, файл должен быть "открываемым", т.е. он не может быть открытым в другом процессе, в-четвертых, у нас должны быть права доступа к файлу и т.д. Предусловия и постусловия основывают контракт между модулем и всеми, кто его вызывает. Тестирование-по-контракту основывается на философии проектирования-по-контракту.

При использовании данного подхода мы создаем только те тест-кейсы, которые удовлетворяют нашим предусловиям. Например, мы не будем тестировать модуль "openFile", если файл не существует. Причина проста. Если файл не существует, то openFile не обещает работать. Если не существует требования работоспособности в определенных условиях, то нет необходимости проводить тестирование в этих условиях.

**Для дополнительной информации**

Для дополнительной информации о проектировании-по-контракту смотрите книгу "Объектно-ориентированное конструирование программных систем" Бертрана Майера. В этот момент тестировщики обычно возражают. Да, они согласны, что модуль не претендует на работу в этом случае, но что делать, если предусловия нарушаются в процессе разработки? Что делать системе? Должны ли мы получить сообщение об ошибке на экране или дымящуюся воронку на месте нашей компании?
Другим подходом к проектированию является оборонительное проектирование. В этом случае модуль предназначен для приема любого входного значения. Если выполнены обычные предусловия, то модуль достигнет своих обычных постусловий. Если обычные предварительные условия не выполняются, то модуль сообщит вызывающему, возвратив код ошибки или бросив исключение (в зависимости от используемого языка программирования). На самом деле, это уведомление является еще одним из постусловий модуля. На основе этого подхода мы могли бы определить оборонительное тестирование: подход, который анализирует как обычные, так и необычные предварительные условия.

**Понимание**

На одном из моих уроков студент, давайте назовем его Фред, сказал, что его не беспокоит, какой подход к проектированию был использован, т.к. он собирался всегда использовать оборонительное тестирование. Когда я спросил: "Почему?", он ответил: "Если модуль не будет работать, то кто будет виноват - вон те ответственные или тестировщики?" Как это относится к тестированию классов эквивалентности? Нужно ли нам делать проверку с такими входными значениями, как -42, FRED и &$#! @? Если мы используем проектирование-по-контракту и тестирование-по-контракту, то ответ "Нет". Если мы используем оборонительное проектирование и, поэтому, оборонительное тестирование, то ответ "Да". Спросите ваших проектировщиков, какой подход они используют. Если их ответом будет «контрактный» либо «оборонительный», то вы знаете, какой стиль тестирования использовать. Если они ответят "Хм?", то это значит, что они не думают о том, как взаимодействуют модули. Они не думают о предусловиях и постусловиях контрактов. Вам стоит ожидать, что интеграционное тестирование будет главным источником дефектов, будет более сложным и потребует больше времени, чем ожидалось.

### Методика

Шаги для тестирования методом классов эквивалентности просты. Во-первых, определите классы эквивалентности. Во-вторых, создайте тестовый сценарий для каждого класса эквивалентности. Вы можете создать дополнительный тестовый сценарий для каждого класса эквивалентности , если у вас есть время и деньги. Дополнительные тестовые сценарии могут дать вам чувство тепла и комфорта, но они редко находят дефекты, которые не смог найти первый сценарий.

**Понимание**

На одном из моих уроков студентка, назовем ее Джуди, чувствовала себя очень не комфортно из-за того, что имела только один тестовый сценарий в каждом классе эквивалентности. Она хотела как минимум два для этого ощущения тепла и комфорта. Я показал, что если у нее есть время и деньги, то этот подход хорош, но предложенные дополнительные тесты, вероятнее всего, будут не эффективны. Я попросил ее проследить, как много раз дополнительные тесты находят дефекты, которые первый тест не нашел, и дать мне об этом знать. Я никогда не слышал Джуди снова. Разные типы входных данных требуют разных типов классов эквивалентности. Давайте рассмотрим четыре возможности. Давайте примем философию оборонительного тестирования для тестирования как верных, так и не верных входных данных. Тестирование некорректных входных значений часто является огромным источником дефектов.

Если входные данные являются непрерывным диапазоном значений, тогда, как правило, существует один класс допустимых значений и два класса некорректных значений (ниже допустимого класса и выше него).

Рассмотрим ипотечную компанию "Гуфи" (ИКГ). Она будет выдавать ипотеки людям с доходами от $1000 до $83333 в месяц. Те, у кого доходы ниже $1000 в месяц, не имеют на это права. Тем, у кого доходы выше $83333 в месяц, не нужна ипотека, т.к. они просто рассчитываются наличными.

Для корректного входного значения можно было бы выбрать $1342 в месяц. Для некорректных - $123 в месяц и $90000 в месяц

![Рисунок 1: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_1.png)

Если входное состояние принимает дискретные значения в пределах диапазона допустимых значений, то обычно существует один корректный и два некорректных класса. ИКГ выдаст ипотеку для покупки от одного до пяти домов (помните, что это "Гуфи"). Ноль или меньше домов, а также шесть и больше - не корректные входные значения. Также это не могут быть ни дробные, ни десятичные значения, такие как 2 1/2 или 3,14159.

![Рисунок 2: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_2.png)

Для корректного входного значения мы могли бы выбрать два дома. Некорректными могут быть -2 и 8. ИКГ может выдавать ипотеки только человеку. Они не выдают ипотеки компаниям, трастам, партнерствам или другим легальным организациям.

![Рисунок 3: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_3.png)

Для верных входных данных мы должны использовать "человек". Для неверных мы можем использовать "корпорация" или "траст" или любую другую случайную строку. Сколько тестовых сценариев с неверными данными следует создать? По крайней мере один; но можно сделать дополнительные тесты, чтобы чувствовать себя тепло и комфортно. ИКГ выдают ипотеки под квартиры, таунхаусы и частные дома. Они не выдают ипотеки под дома на двух хозяев, передвижные дома, домики на дереве или другие типы жилья.

![Рисунок 4: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_4.png)

Для верных входных данных мы можем выбрать значение "квартира", "таунхаус" или "частный дом". Несмотря на то, что правило указывает выбрать один тест из класса эквивалентности, более комплексный подход заключается в создании тестового сценария на каждое значение в классе эквивалентности. Это имеет смысл, если список верных значений мал. Но, если у нас список из пятидесяти штатов, Штат Колумбия и различные территории США, будете ли вы тестировать все значения? Что, если в списке все страны мира? Правильный ответ, конечно, зависит от рисков организации, если, как тестировщики, мы пропустим что-либо жизненно важное.

Очень редко у нас будет время на создание отдельных тестов для каждого отдельного класса эквивалентности всех входных данных, вводимых в нашу систему. Чаще мы будем создавать тестовые сценарии, которые будут проверять некоторое число полей ввода одновременно. Например, мы можем создать один тестовый сценарий для следующих комбинаций входных данных:

| Ежемесячный доход | Количество жилых помещений  | Заявитель | Вид жилья | Результат |
| --- | --- | --- | --- | --- |
| $5000 | 2 | Человек | Квартира | корректное значение |

*Тестовый сценарий для верных входных данных.*

**Ключевой момент**

Очень редко у нас будет время на создание отдельных тестов для каждого отдельного класса эквивалентности для каждого входного значения.
Каждое из этих значений в диапазоне допустимых, поэтому мы ожидаем корректной работы системы и успешного отчета о прохождении теста.
Заманчиво использовать такой же подход к тестированию неверных значений.

| Ежемесячный доход | Количество жилых помещений  | Заявитель | Вид жилья | Результат |
| --- | --- | --- | --- | --- |
| $100 | 8 | Партнерство | Домик на дереве | некорректное значение |

*Тестовый сценарий неверных данных. Это плохой подход.*

Если система принимает эти данные как верные, то ясно, что система не проверяет все четыре поля для ввода как следует. Но если система отклонит эти данные как неверные, то тестировщик не сможет понять, какое поле было отклонено. Например:
ERRROR: 653х-2.7 неверные входные данные

Во многих случаях ошибки в одном поле ввода могут свести на нет или замаскировать ошибки в другом поле, в результате чего система принимает данные как корректные. Лучше было бы проверить одно недопустимое значение за раз, чтобы убедиться, что система распознает его корректно.

| Ежемесячный доход | Количество жилых помещений  | Заявитель | Вид жилья | Результат |
| --- | --- | --- | --- | --- |
| $100 | 1 | Человек | Квартира | некорректное значение |
| $1342 | 0 | Человек | Частный дом | некорректное значение |
| $1342 | 1 | Корпорация | Таунхаус | некорректное значение |
| $1342 | 1 | Человек | Домик на дереве | некорректное значение |

*Набор тест-кейсов, различающихся на одно недопустимое значение.*

Чтобы чувствовать себя тепло и комфортно, входные значения (как корректные, так и некорректные) могут варьироваться.

| Ежемесячный доход | Количество жилых помещений  | Заявитель | Вид жилья | Результат |
| --- | --- | --- | --- | --- |
| $100 | 1 | Человек | Квартира | некорректное значение |
| $1342 | 0 | Человек | Частный дом | некорректное значение |
| $$5432 | 3 | Корпорация | Таунхаус | некорректное значение |
| $10000 | 2 | Человек | Домик на дереве | некорректное значение |

*Набор тест-кейсов, различающихся на одно недопустимое значение, но с различающимися допустимыми значениями.*

Другой подход к использованию классов эквивалентности заключается в изучении не входных, а выходных значений. Разделите выходные значения на классы эквивалентности, и тогда можно будет определить, какие входные значения будут причиной этих выходных значений. Преимущество такого подхода в том, что тестировщик направляется исследовать и таким образом тестирует все различные типы выходных данных.

Но этот подход может быть обманчивым. В предыдущем примере одним из выходных значений системы отдела кадров было "НЕТ", что означало "Не нанимать". Беглый осмотр входных значений, которые должны привести к такому выходному значению, даст {0, 1, ..., 14, 15}. Отмечу, что это далеко не полный набор. Кроме того, набор {55, 56, ..., 98, 99} должен так же привести к выходному значению "НЕТ". Важно убедиться, что могут быть получены все потенциальные выходные значения, но не обманывайте себя, выбирая данные для классов эквивалентности, которые опускают важные входные значения.

### Примеры

**Пример 1**

Ссылаясь на веб-страницу Заказа веб-сайта "Браун и Дональдсон", описанного в Приложении А, рассмотрим поле "Тип заказа". Дизайнер выбрал радио-кнопки для реализации выбора между операциями покупки или продажи. Это хороший дизайнерский выбор, потому что он уменьшает количество тестов, которые должен создать тестировщик. Если бы это было реализовано в виде текстового поля, в котором пользователь вводил "Купить" или "Продать", то тестировщику нужно было бы отличать корректные входные значения, такие как {Купить, Продать} и некорректные, такие как {Торговля, Ставка, ...}. А что насчет "купить" "кУпить", "КУПИТЬ"? Корректными или некорректными являются эти записи? Для определения их статуса тестировщику нужно было бы обратиться к требованиям. При реализации радио-кнопки не существует неправильных значений для выбора, поэтому и нет необходимости в проверке таких значений. Должны выполняться только корректные входы {Купить, Продать}.

Понимание

Пусть ваши дизайнеры и программисты знают, когда они помогли вам. Они оценят эту мысль и смогут делать это снова.

**Пример 2**

Опять же, ссылаясь на веб-страницу Заказа, рассмотрим поле "Количество". Входным значением в этом поле могут быть от одной до четырех цифр (0, 1, ..., 8, 9) с допустимым значением, большим или равным 1, и меньшим или равным 9999. Набором допустимых входов являются {1, 22, 333, 4444}, а недопустимых -
{-42, 0, 12345, SQE, #$@%}.

Понимание

Часто ваши проектировщики и программисты используют средства проектирования графического интерфейса пользователя, которые могут ввести ограничения на длину и содержание полей ввода.
Поощряйте их использование. Тогда во время тестирования вы можете сосредоточиться на получении уверенности в том, что этот инструмент должным образом реализует требования.

**Пример 3**

На странице Заказа пользователь вводит символьный идентификатор, указывающий на акции для купли или продажи. Допустимыми символами являются {А, АА, AABC, AAC, ..., ZOLT, ZOMX, ZONA, ZRAN).
Недопустимыми символами является любое сочетание символов, не включенных в список допустимых. Набор допустимых входных значений может быть {A, AL, ABE, ACES, AKZOY), в то время как набор недопустимых может быть {C, AF, BOB, CLUBS, AKZAM, 42, @#$%).

Дополнительная информация

Нажмите на кнопку "Поиск символа" на странице Заказа сайта "Браун и Дональдсон", чтобы увидеть полный список символов акций.

**Пример 4**

Изредка мы будем создавать отдельные наборы тестов для каждого входного значения. Обычно это наиболее эффективно для того, чтобы одновременно проверить несколько входных значений в течение тестирования. Например, следующие тесты объединяют Купить / Продать, Идентификатор и Количество.

| Купить / Продать | Идентификатор  | Количество | Результат |
| --- | --- | --- | --- |
| Купить | A | 10 | корректно |
| Купить | C | 20 | некорректно |
| Купить | A | 0 | некорректно |
| Продать | ACES | 10 | корректно |
| Продать | BOB | 33 | некорректно |
| Продать | ABE | -3 | некорректно |

*Набор тестов, включающих недопустимые значения по одному.*

### Применения и ограничения

Тестирование классов эквивалентностей может значительно уменьшить количество тестов, которые должны быть созданы и выполнены. Такое тестирование больше всего подходит для систем, в которых большая часть входных данных принимает значения в пределах диапазонов или из наборов данных. Оно базируется на предположении, что данные из одного и того же класса эквивалентности по сути, обрабатываются в системе одинаковым образом. Самым простым способом проверить это предположение является спросить программиста о его реализации. Тестирование классов эквивалентности в равной степени применимо на модульном, интеграционном, системном и приемочном уровнях тестирования. Все это требует входных или выходных значений, которые могут быть разделены на основе системных требований.

### Резюме

Тестирование классов эквивалентности - это техника, используемая для уменьшения числа тестовых наборов до выполнимого уровня при сохранении приемлемого уровня покрытия тестами. Эта простая техника используется интуитивно почти всеми тестировщиками, даже если они не знают о ней формально как о методе тест-дизайна.

Класс эквивалентности представляет собой набор данных, которые либо одинаково обрабатываются модулем, либо их обработка выдает одинаковые результаты. При тестировании любое значение данных, входящее в класс эквивалентности, аналогично любому иному значению класса.

### Практика

Следующие упражнения относятся к веб-сайту Регистрационной системы Государственного университета, описанному в приложении Б. Определите классы эквивалентности и подходящие тест-кейсы для следующего:
  - a. ZIP-код - пять цифр.
  - b. Штат - двухсимвольная аббревиатура стандарта почты для штатов, районов, территорий и т.д. Соединенных Штатов.
  - c. Фамилия - пятнадцать символов (включая алфавитные символы, точку, дефис, апостроф, пробел и цифры).
  - d. Идентификатор пользователя - восемь символов, как минимум два из которых не алфавитные (число, спецсимвол, непечатаемый символ).
  - e. Идентификатор студента - восемь символов. Первые два представляют собой номер студенческого общежития, а последние шесть являются уникальным шестизначным номером.
Допустимые сокращения общежитий: AN (Annandale); LC (Las Cruces); RW (Riverside West); SM (San Mateo); TA (Talbot); WE (Weber) и WN (Wenatchee).

Литература
Beizer, Boris​ (1990). ​ Software Testing Techniques. Van Nostrand Reinhold.
