# Глава 7. Тестирование состояний и переходов

> "Полковник Клетус Йорбвиль был одиноким страшно скучающим астронавтом в течение первых нескольких месяцев его дипломатической миссии на третьей планете системы Франгеликус XIV. Но все изменилось в тот день, когда он открыл, что его крошечный многоногий и бесконечно гостеприимный инопланетянин-хозяин оказался не только съедобным, но и замечательным на вкус, примерно как начинка , которая оставлена на сковороде, после того, как вы сделали булочки с корицей и поджарили их немного." Марк Силкокс

### Введение

Диаграммы состояний и переходов, как и таблицы принятия решений – ещё один замечательный инструмент для фиксации определенных видов системных требований и для документирования внутреннего дизайна системы. Такие диаграммы документируют входящие события, которые обрабатываются системой так же, как системные ответы. В отличие от таблиц решений, они очень немного определяют с точки зрения правил обработки. Когда система должна помнить что-то о том, что случилось ранее или если возможен правильный и неправильный порядок операций, то диаграммы состояний и переходов – идеальный инструмент для фиксации такой информации.

Эти диаграммы являются жизненно важными в наборе персональных инструментов тестировщика. К сожалению, многие аналитики, проектировщики, программисты и тестировщики не знакомы с этой методикой.

### Методика

**Диаграммы состояний и переходов**

Понятие "диаграмма состояний и переходов" проще объяснить на примере, чем с помощью формального определения. Поскольку ни "Браун и Дональдсон", ни "Регистрационная система Государственного университета" не содержат существенных требований, основанных на состояниях переходов, давайте рассмотрим другой пример.

Чтобы приехать в Государственный университет, нам нужно забронировать авиабилет. Давайте позвоним для этого нашему любимому перевозчику (Grace L. Ferguson Airline & Storm Door Company). Мы сообщаем некоторую информацию, в том числе откуда и куда нам нужно лететь, даты и время вылета и прибытия в точку назначения. Агент бронирования, выступающий в роли связующего звена с системой бронирования авиакомпании, использует эту информацию, чтобы осуществить бронирование. Теперь бронирование
находится в состоянии "​ Осуществлено​ ". В дополнение, система создает и запускает таймер. Каждое бронирование имеет определенный промежуток времени, в течение которого оно должно быть оплачено.

Эти правила зависят от пункта назначения, класса обслуживания, дат и так далее. Если время истекает до того, как бронирование оплачено, то система его отменяет. В нотации "состояние-переход" эта информация записана как:

![Рисунок 24: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_24.png)

*Бронирование осуществлено*

Кружок представляет одно из состояний бронирования - в данном случае, состояние "Осуществлено". Стрелка указывает на переход в состояние "Осуществлено". Описание на стрелке "вводИнформации" - это событие, которое поступает в систему из внешнего мира. Команда после символа "/" обозначает действие системы, в данном случае старт ТаймераОплаты. Чёрная точка указывает на стартовую позицию диаграммы.
Иногда после выполнения бронирования, но (надеюсь) до истечения срока на таймере, бронирование оплачивают. Это действие представлено стрелкой, обозначенной "оплата". После оплаты бронирование переходит из состояния "​ Осуществлено​ " в состояние "​ Оплачено​ ".

![Рисунок 25: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_25.png)

*Переход бронирования в состояние "Оплачено"*

Перед тем, как продолжить, дадим некоторым терминам более формальное определение:
  - Состояние​ (изображается в виде круга) - это состояние, в котором система ожидает возникновения одного или нескольких событий. Состояния "помнят" информацию извне, полученную системой в прошлом, и определяют, как система должна реагировать на последующие события, когда они произойдут. Эти события могут служить причиной изменения состояния и/или вызывать действия. Состояние обычно представляется как значение одной или нескольких переменных в системе.
  - Переход​ (изображается в виде стрелки) - это изменение состояния из одного в другое, произошедшее благодаря какому-то событию.
  - Событие​ (представлено надписью над стрелкой перехода) - что-то, что вызывает изменение состояния системы. Обычно это событие во внешнем мире, информация о котором вводится в систему через её интерфейс. Некоторые события генерируются внутри системы, например, истечение срока таймера или опустившееся до точки пополнения запасов количество предметов в наличии. События считаются мгновенными. События могут быть независимыми или причинно-связанными (событие B не может произойти прежде события А). Когда происходит событие, система может изменить свое состояние или остаться в том же состоянии и/или выполнить действие. События могут иметь параметры, связанные с ними. Например, "Плата денег" может означать оплату наличными, чеком, дебетовой картой или кредитной картой.
  - Действие​ (представлено в виде команды, следующей за "/") - это операция, которая вызвана изменением состояния. Это может быть ​ печать билета, ​ отображение экрана, ​ включение двигателя и т.д. Часто эти действия служат причиной создания каких-либо выходных значений системы. Обратите внимание, что действия происходят при переходах между состояниями. Сами состояния пассивны.
  - Входная точка на диаграмме показана черной точкой, а точка выхода показана в виде значка "бычьего глаза".

Такая нотация была создана Мили. Муром была определена альтернативная нотация, но она используются реже. Для более глубокого обсуждения диаграмм состояний и переходов посмотрите книгу М. Фаулера и К. Скотта "​ UML. Основы: Краткое руководство по стандартному языку объектного моделирования". В ней рассматриваются более сложные вопросы, например, разделенные и вложенные диаграммы состояний и переходов.

Обратите внимание, что диаграмма состояний и переходов представляет один конкретный объект (в данном случае ​ Бронирование​ ). Она описывает состояния бронирования, события, которые влияют на бронирование, переходы из одного состояния в другое, а также действия, которые инициируются бронированием. Распространенной ошибкой является смешивание различных объектов в одной диаграмме состояний и переходов. Например, смешивание ​ бронирования​ и ​ пассажира​ с событиями и действиями, соответствующими каждому.

Из состоянии "​ Оплачено​ " бронирование переходит в состояние "​ Обилечено​ ", когда выполняется команда печати (событие). Отмечу, что в дополнение к переходу в состояние "Обилечено", также система выдает Билет​ .

![Рисунок 26: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_26.png)

*Переход бронирования в состояние "Обилечено".*

Из состояния "Обилечено" мы выдаем билет, который позволит зайти на борт самолета.

![Рисунок 27: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_27.png)

*Переход бронирования в состояние "Использовано".*

После какого-нибудь другого действия или периода времени, не указанных на этой диаграмме, путь состояний и переходов заканчивается значком "бычьего глаза".

![Рисунок 28: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_28.png)

*Путь заканчивается.*

Показывает ли эта диаграмма все возможные состояния, события и переходы жизненного цикла бронирования​ ? Нет. Если заказ не оплачен в отведенное время (до истечения ТаймераОплаты), то он будет отменен из-за неуплаты.

![Рисунок 29: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_29.png)

*Срок оплаты истек и бронирование отменено за неуплату*

Теперь всё? Нет. Заказчики иногда отменяют свои заказы. Из состояния "​ Выполнено​ " заказчик (через агента бронирования) просит отменить заказ. Требуется новое состояние "​ Отменено заказчиком​ ".

![Рисунок 30: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_30.png)

*Отмена бронирования из состояния "Осуществлено".*

Кроме того, Бронирование может быть отменено из состояния "​ Оплачено​ ". В этом случае надо выполнить возврат денег и выйти из системы. В результате снова будет состояние "​ Отменено заказчиком​ ".

![Рисунок 31: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_31.png)

*Отмена бронирования из состояния "Оплачено".*

И последнее дополнение. Заказчик может отменить бронирование из состояния "​ Обилечено​ ". В этом случае должен быть сформирован возврат денег и следующим состоянием должно быть "​ Отменено заказчиком​ ". Но этого не достаточно. Авиакомпания произведет возмещение, но только тогда, когда получит от заказчика распечатанный билет. Это вводит еще одно обозначение - квадратные скобки [ ], которые содержат условие, которое может принимать одно из двух значений: истина (True) или ложь (False). Данное условие ведет себя как охранник, позволяющий переход, только если условие истинно.

![Рисунок 32: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_32.png)

*Отмена бронирования из состояния "Обилечено".*

Отмечу, что диаграмма всё еще не завершена. Нет стрелки для перехода в "бычий глаз" из состояний "Отменено". Возможно, мы могли бы восстановить бронирование из состояния "Отменено (не оплачено)". Мы могли бы и дальше расширять диаграмму, включив выбор места, отмену рейса и другие значимые события, влияющие на бронирование, но для того, чтобы продемонстрировать технику, достаточно и этого. Как проиллюстрировано, диаграммы состояний и переходов выражают сложные системные правила и взаимодействия в очень компактной форме. Будем надеяться, что когда эта сложность существует, аналитики и проектировщики будут создавать диаграммы состояний и переходов к документу с системными требованиями и будут использовать их для проектирования.

**Таблицы состояний и переходов**

Диаграмма состояний и переходов - не единственный способ документирования поведения системы. Диаграммы, возможно, легче в понимании, но таблицы состояний и переходов могут быть проще в использовании на постоянной и временной основе. Таблицы состояний и переходов состоят из четырех столбцов - "​ Текущее состояние​ ", "​ Событие​ ", "​ Действие​ " и "​ Следующее состояние​ ".

| Текущее состояние | Событие | Действие | Следующее состояние |
| --- | --- | --- | --- |
| пусто | ввод информации | старт таймера оплаты | осуществленно |
| пусто | оплата | - | пусто |
| пусто | печать | - | пусто |
| пусто | выдача билета | - | пусто |
| пусто | отмена | - | пусто |
| пусто | срок оплаты истек | - | пусто |
|  |  |  |  |
| осуществленно | ввод информации | - | осуществленно |
| осуществленно | оплата | - | оплачено |
| осуществленно | печать | - | осуществленно |
| осуществленно | выдача билета | - | осуществленно |
| осуществленно | отмена | - | отменено заказчиком |
| осуществленно | срок оплаты истек | - | отменено (не оплачено) |
|  |  |  |  |
| оплачено | ввод информации | - | оплачено |
| оплачено | оплата | - | оплачено |
| оплачено | печать | билет | обилечено |
| оплачено | выдача билета | - | оплачено |
| оплачено | отмена | возврат денег | отменено заказчиком |
| оплачено | срок оплаты истек | - | оплачено |
|  |  |  |  |
| обилечено | ввод информации | - | обилечено |
| обилечено | оплата | - | обилечено |
| обилечено | печать | - | обилечено |
| обилечено | выдача билета | - | использовано |
| обилечено | отмена | возврат денег | отменено заказчиком |
| обилечено | срок оплаты истек | - | обилечено |
|  |  |  |  |
| использовано | ввод информации | - | использовано |
| использовано | оплата | - | использовано |
| использовано | печать | - | использовано |
| использовано | выдача билета | - | использовано |
| использовано | отмена | - | использовано |
| использовано | срок оплаты истек | - | использовано |
|  |  |  |  |
| отменено (не оплачено) | ввод информации | - | отменено (не оплачено) |
| отменено (не оплачено) | оплата | - | отменено (не оплачено) |
| отменено (не оплачено) | печать | - | отменено (не оплачено) |
| отменено (не оплачено) | выдача билета | - | отменено (не оплачено) |
| отменено (не оплачено) | отмена | - | отменено (не оплачено) |
| отменено (не оплачено) | срок оплаты истек | - | отменено (не оплачено) |
|  |  |  |  |
| отменено заказчиком | ввод информации | - | отменено заказчиком |
| отменено заказчиком | оплата | - | отменено заказчиком |
| отменено заказчиком | печать | - | отменено заказчиком |
| отменено заказчиком | выдача билета | - | отменено заказчиком |
| отменено заказчиком | отмена | - | отменено заказчиком |
| отменено заказчиком | срок оплаты истек | - | отменено заказчиком |

*Таблица состояний и переходов для бронирования*

Преимущество таблицы состояний и переходов в том, что в ней перечисляются все возможные комбинации состояний и переходов, а не только допустимые. При крайне необходимом тестировании систем с высокой степенью риска, например авиационной радиоэлектротехники или медицинских устройств, может потребоваться тестирование каждой пары состояние-переход, включая те, которые не являются допустимыми. Кроме того, создание таблицы состояний и переходов часто извлекает комбинации, которые не были определены, задокументированы или рассмотрены в требованиях. Очень полезно обнаружить эти дефекты до начала кодирования.

**Ключевой момент**

Преимущество таблицы состояний и переходов в том, что в ней перечисляются все возможные комбинации состояний и переходов, а не только допустимые.

Использование таблицы состояний и переходов может помочь обнаружить дефекты в реализации, которые позволяют недопустимые пути из одного состояния в другое. Недостатком таких таблиц является то, что, когда количество состояний и событий возрастает, они очень быстро становятся огромными. Кроме того, в таблицах, как правило, большинство клеток пустые.

**Создание тест-кейсов**

Информация в диаграммах состояний и переходов легко может быть использована для создания тестов.

Определим четыре разных уровня покрытия:
  - Набор тестов, в котором ​ все состояния​ будут посещены как минимум один раз. Этому требованию удовлетворяет набор из трех тестов, показанный ниже. Обычно это низкий уровень тестового покрытия.

  ![Рисунок 33: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_33.png)

  *Набор тестов, которые "посещают" каждое состояние.*

  - Набор тестов, в котором ​ все события​ выполнятся как минимум один раз. Следует отметить, что тест-кейсы, которые покрывают каждое событие, могут быть точно теми же, которые покрывают каждое состояние. Опять же, это низкий уровень покрытия.

  ![Рисунок 34: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_34.png)

  *Набор тестов, в котором все события выполняются по крайней мере один раз.*

  - Набор тестов, в котором​ все пути​ будут пройдены как минимум один раз. Несмотря на то, что этот уровень является наиболее предпочтительным из-за его уровня покрытия, это может быть неосуществимо. Если диаграмма состояний и переходов содержит петли, то количество возможных путей может быть бесконечным. Например, дана система с двумя состояниями А и В, где А переходит в В и В переходит в А. Некоторые из возможных путей:
    - A->B
    - A->B->A
    - A->B->A->B->A->B
    - A->B->A->B->A->B->A
    - A->B->A->B->A->B->A->B->A->B

  и так до бесконечности. Тестирование таких петель, как эта, может быть важным, если они могут привести к
  накоплению вычислительных ошибок или потери ресурсов (блокировки без соответствующего
  высвобождения данных, утечки памяти и т.д.).

  - Набор тестов, в котором ​ все переходы​ будут осуществлены как минимум один раз. Этот уровень тестирования обеспечивает хороший уровень покрытия без порождения большого количества тестов. Этот уровень, как правило, один из рекомендованных.

  ![Рисунок 35: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_35.png)

  *Набор тестов, в котором все переходы осуществляются по крайней мере один раз.*

**Ключевой момент**

Как правило, рекомендуемым уровнем покрытия для диаграмм состояний и переходов является тестирование ​ каждого перехода​ .

Кроме того, в зависимости от системного риска, вы можете создавать тест-кейсы для некоторых или всех недопустимых пар состояние/событие для того, чтобы убедиться, что система не реализует неверные пути.

### Применение и ограничения

Диаграммы состояний и переходов являются отличными инструментами для захвата определенных системных требований, а именно таких, которые описывают состояния и связанные с ними переходы. Эти диаграммы могут использоваться для того, чтобы направить наши усилия по тестированию на выявление состояний, событий и переходов, которые должны быть проверены.

Диаграммы состояний и переходов не применяются, если система не имеет ни одного состояния или не должна реагировать в реальном времени на события, возникающие вне пределов системы. Примером может служить программа начисления заработной платы, которая считывает отработанное работником время, вычисляет зарплату, вычитает отчисления, сохраняет запись, печатает зарплатный чек, а затем процесс повторяется.

### Резюме

Диаграммы состояний и переходов направляют наши усилия по тестированию на выявление состояний, событий, действий и переходов, которые должны быть проверены. Совместно они определяют, как система взаимодействует с внешним миром, событиями его процессов, а также допустимые и недопустимые значения этих событий.

Диаграмма состояний и переходов - это не единственный способ документирования поведения системы. Возможно, они более легки для понимания, но таблицы состояний и переходов могут быть проще в использовании на постоянной и временной основе.

Рекомендуемым уровнем тестирования с использованием диаграмм состояний и переходов является создание такого набора тестов, в котором все переходы осуществляются по крайней мере один раз. В системах с высокой степенью риска можно создать еще больше тест-кейсов, приближаясь ко всем возможным путям.

**Практика**
- Это упражнение относится к веб-сайту регистрационной системы Государственного университета, описанной в приложении Б. Ниже приведена диаграмма состояний и переходов для процесса "регистрации на курс" и "исключения из курса". Определите набор тестов, которые вы считаете достаточными для покрытия процесса регистрации и исключения.
В диаграмме используются следующие термины:

**События:**
  - create (создать) - создать новый курс,
  - enroll (зачислить) - зачислить студента на курс,
  - drop (исключить) - исключить студента из курса.

**Атрибуты:**
  - ID - номерной идентификатор студента,
  - max - максимальное количество студентов, которое может содержать в себе курс,
  - #enrolled - количество студентов, которые в настоящее время зачислены на курс,
  - waiting- количество студентов, которые в настоящее время находятся в Списке Ожидания для этого курса.

**Тесты:**
  - isEnrolled - отвечают на вопрос "зачислен ли студент на курс?",
  - onWaitList - отвечают на вопрос "находится ли студент в Списке Ожидания?".

**Списки:**
  - SectionList - список студентов, зачисленных в группу,
  - WaitList - список студентов, ожидающих зачисление в заполненную группу.

**Символы:**
  - ++ - увеличение на 1,
  - -- - уменьшение на 1.

![Рисунок 36: Непрерывные классы эквивалентности](https://raw.githubusercontent.com/kostyashelest/software-test-design/master/img/img_36.png)

*Диаграмма состояний и переходов для зачисления и исключения из курса в Государственный университет.*

**Ссылки**

Binder, Robert V.​ (1999). ​ Testing Object-Oriented Systems: Models, Patterns, and Tools. Addison-Wesley.
Fowler, Martin and Kendall Scott ​ (1999). U
ML Distilled: A Brief Guide to the Standard Object Modeling
Language (2 nd Edition). Addison-Wesley.
Harel, David. ​ "Statecharts: a visual formalism for complex systems." S
cience of Computer Programming 8, 1987,
pp 231–274.
Mealy, G.H. ​ "A method for synthesizing sequential circuits." B
ell System Technical Journal, 34(5): 1045–1079,
1955.
Moore, E.F. ​ "Gedanken-experiments on sequential machines," A
utomata Studies (C. E. Shannon and J.
McCarthy, eds.), pp. 129–153, Princeton, New Jersey: Princeton University Press, 1956.
Rumbaugh, James, et al. ​ (1991). ​ Object-Oriented Modeling and Design. Prentice-Hall.
